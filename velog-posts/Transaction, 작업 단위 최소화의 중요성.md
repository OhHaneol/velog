<h3 id="트랜잭션이-무엇인가요">트랜잭션이 무엇인가요?</h3>
<blockquote>
<p>🙋 논리적인 작업 단위입니다!</p>
</blockquote>
<p>트랜잭션이 모두 성공하는 경우 이 SQL문들은 전부 commit 되며, 하나라도 실패한다면 전체가 rollback 됩니다.</p>
<p>그래서 더 이상 쪼갤 수 없는 작은 단위의 특성을 Atomicity, 즉 원자성이라고 하며, 우리 개발자는 커밋과 롤백의 지점에 대해 기준을 세우고 코드를 작성해야 합니다.</p>
<p>그런데 혹시, 원자성이 지켜지지 않을 경우에 대해 생각해보셨나요?</p>
<h3 id="작업-단위가-커질-경우의-위험성">작업 단위가 커질 경우의 위험성</h3>
<blockquote>
<p>앗! 😬 하나의 트랜잭션에 많은 기능을 넣었어요!</p>
</blockquote>
<p>네, 계속해서 일부 작업만 성공하고 나머지 작업이 실패하며 시스템이 불안정해지고 있군요.</p>
<ol>
<li>롤백이나 보상 트랜잭션을 실행하면 되지 않으냐구요? 보상 메커니즘 또한 제대로 설계되지 않을 경우, 추가적인 트랜잭션이 필요하게 되어 <strong>트랜잭션이 장기간 실행될 수 있어요!</strong></li>
<li>추가로 트랜잭션 도중 데이터 잠금이 해제되지 않거나, 부분적으로 유지되어 다른 트랜잭션이 대기 상태에 들어가게 돼요. 이 경우에도 <strong>시스템 전체의 성능 저하</strong>를 초래하며 <strong>장기 트랜잭션</strong>으로 이어질 수 있겠네요.</li>
</ol>
<h3 id="mysql의-장기-트랜잭션-활성화-대비">MySQL의 장기 트랜잭션 활성화 대비</h3>
<blockquote>
<p>🫢 그렇게 위험하다구요?!</p>
</blockquote>
<p>물론 이러한 교착 상태로 인한 성능 저하의 경우도 DB에서 대비하고는 있어요.
<code>MySQL</code>을 기준으로 <code>InnoDB 스토리지 엔진</code>은 내부적으로 잠금이 교착 상태에 빠졌는지를 관리하기 위해 잠금 대기 목록을 그래프 형태로 관리하고, <strong>데드락 감지 스레드</strong>가 주기적으로 이 그래프를 검사하여 교착 상태에 빠진 트랜잭션을 찾아내어 그 중 하나를 <strong>강제 종료</strong>시키고 있어요!</p>
<h3 id="그럼에도-작업-단위를-최소화해야-하는-이유">그럼에도 작업 단위를 최소화해야 하는 이유</h3>
<blockquote>
<p>🥺 그럼 마음 놓고 개발하면 안 될까요...</p>
</blockquote>
<p>백날천날 데드락 감지 스레드만 믿고 바라봐서는 안 되는 두 가지 이유가 있어요.</p>
<p>📍 먼저 <strong>롤백으로 인한 MySQL 서버 부하</strong>의 우려! 데드락 감지 스레드는 강제 종료 시 종료 우선순위를 고려하는데, 이 때 롤백 대상이 되는 트랜잭션은 바로 <strong>언두 로그(Undo Log)</strong>의 양이 적은 것입니다!</p>
<p>언두 로그 레코그가 적다
= 롤백 시 언두 처리를 해야 하는 내용이 적다
= 트랜잭션 강제 롤백으로 인한 MySQL 서버 부하가 덜하다</p>
<p>(참고로 <strong>언두 로그</strong>란, UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳 입니다.)</p>
<p>그런데 트랜잭션의 원자성을 고려하지 않고 개발하면 이 언두 로그 레코드가 무지막지하게 쌓일 수도 있겠죠?</p>
<p>📍 다음으로 <strong>데드락 감지 스레드 자체로 인한 서버 부하</strong>의 우려! 데드락 감지 스레드는 잠금 목록을 검사한다고 했죠? 따라서 이러한 잠금 상태가 변경되지 않도록, 또 다시 잠금 목록이 저장된 잠금 테이블에 새로운 잠금을 걸고 데드락 스레드를 찾아나서요.</p>
<p>그런데 여기서 문제! <strong>데드락이 교착 점검을 하러 들어가서 잠금이 걸리면?</strong> 게다가 이 데드락이 일을 빨리빨리 진행하지 못한다면?!
-&gt; 서비스 쿼리를 수행하던 스레드까지 무한정 대기에 들어가며 서비스에 악영향이 가겠네요. 여기서 만약 잦은 DB 변경이나 조회로 인해 동시 처리 스레드가 매우 많은 경우, 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있어요!</p>
<h3 id="데드락-감지-스레드의-on-off">데드락 감지 스레드의 On, Off</h3>
<blockquote>
<p>😤 아하! 이제 원자성은 지켜야 한다는 걸 알겠어요.
근데 말씀대로라면 원자성을 지키더라도 데드락이 교착 상태를 해결하려다 오히려 악영향을 끼칠 수도 있는 것 아닌가요?</p>
</blockquote>
<p>맞아요! 그래서 매우 높은 동시성 처리를 요구하는 서비스에 대해, MySQL의 <code>innodb_deadlock_detect</code>라는 시스템 변수를 사용하여 해결할 수 있어요.</p>
<ol>
<li>해당 변수를 off 하여 데드락 감지 스레드의 작동을 멈추고,</li>
<li>교착 상태의 중재 공백에 대해 <code>innodb_lock_wait_timeout</code> 시스템 변수를 on 하여 데드락에서 일정 시간 소요 시 자동으로 요청 실패 및 에러 메시지를 반환할 수 있어요. (이 때 기본 50초보다 훨씬 낮은 값으로 변경하는 걸 권장!)</li>
</ol>
<p>지금까지 원자성을 지켜야 하는 이유를 DB와 연결하여 알아보았습니다!</p>