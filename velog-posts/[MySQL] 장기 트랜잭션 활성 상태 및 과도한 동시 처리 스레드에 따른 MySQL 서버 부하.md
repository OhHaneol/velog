<h2 id="📍-언두-로그의-유지에-따른-서버-부하-해결">📍 언두 로그의 유지에 따른 서버 부하 해결</h2>
<p>언두 로그는 더 이상 해당 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다. 즉, 장기 활성된 트랜잭션이 늘어날 수록 <strong>일관된 읽기</strong>를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 한다.</p>
<p>이는 가끔 MySQL 서버가 느려지거나 문제가 발생하는 원인이 되기도 한다.(그니까 빠른 롤백과 커밋 필수필수)</p>
<blockquote>
<p>일관된 읽기?
InnoDB 스토리지 엔진은 잠금 없이도, MVCC 를 이용하여 격리 수준에 따른 읽기를 가능하게 한다.</p>
</blockquote>
<h2 id="📍-교착-상태에-빠진-트랜잭션으로-인한-서버-부하-해결">📍 교착 상태에 빠진 트랜잭션으로 인한 서버 부하 해결</h2>
<p>InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다.</p>
<p>다행히도 InnoDB 스토리지 엔진은 <strong>데드락 감지 스레드</strong>가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 <strong>강제 종료</strong>한다. 이 때 종료 우선순위가 높은, 즉 롤백 대상이 되는 트랜잭션은 언두 로그의 양이 적은 것이다.</p>
<p>언두 로그 레코드가 적다
= 롤백 시 언두 처리를 해야 하는 내용이 적다
= 트랜잭션 강제 롤백으로 인한 MySQL 서버 부하가 덜하다</p>
<h2 id="📍-데드락-감지-스레드로-인한-서버-부하-해결">📍 데드락 감지 스레드로 인한 서버 부하 해결</h2>
<p>데드락 감지 스레드는 잠금 목록을 검사한다. 따라서 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트(잠금 테이블)에 새로운 잠금을 걸고 데드락 스레드를 찾는다.</p>
<h3 id="😡-문제">😡 문제</h3>
<p>데드락이 교착 점검을 하러 들어가서 <strong>잠금이 걸렸다!</strong> 그런데 이 데드락이 빨리빨리 일을 진행하지 못한다?!  → 서비스 쿼리를 수행하던 스레드도 <strong>무한정 대기</strong>에 들어가면서 서비스에 악영향이 간다.</p>
<p>이렇게 잦은 DB 변경이나 조회로 인해 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.</p>
<h3 id="💗-해결">💗 해결</h3>
<p>이렇게 데드락이 교착을 해결하려다 오히려 서비스에 해를 끼친다? → <code>innodb_deadlock_detect</code> 시스템 변수를 off 하면 데드락 감지 스레드 작동이 멈춘다.</p>
<p>근데 이러면 또 <strong>교착 상태가 발생</strong>해도 중재가 없어서 또 무한정 대기로 해를 끼친다? → <code>innodb_lock_wait_timeout</code> 시스템 변수를 on(활성화) 하면 데드락에서 일정 시간 지날 시 자동으로 요청 실패 및 에러 메시지 반환으로 이어진다.(이는 초 단위 설정 가능)</p>
<h3 id="✅-결론">✅ 결론</h3>
<p>데드락 부담스럽다 ㅠㅠ <code>innodb_deadlock_detect</code> off 할 거임 → <code>innodb_lock_wait_timeout</code> 을 기본 50초보다 훨씬 낮은 값으로 변경해서 사용 권장!</p>
<p>추가로 이러한 사실은 구글에서 발견했다! 만약 PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 innodb_deadlock_detect 비활성화해서 성능 비교하는 것이 도움이 될 듯 하다.</p>
<h2 id="📑-참고-자료">📑 참고 자료</h2>
<ul>
<li>Real MySQL 8.0 1권</li>
</ul>